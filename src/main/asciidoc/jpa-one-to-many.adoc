:revnumber: {docVersion}
:toclevels: 3

= [red]#JPA regarding relationships#
{docDate}

== Introductie

During this part of the training we will instruct using JPA

. OneToMany 
. ManyToOne 
. ManyToMany

== Definitions
.Some definitions
* Unidirectional vs bidirectional
* OneToMany 
* ManyToOne 
* ManyToMany

== @OneToOne

=== Unidirectional

Suppose an Employee always has a single address and we have to model it in jpa

image::ObjectRelational-OneToOne.jpg[]

So we create the entity Addresss

[source, java]
----
package nl.programit.people.domain;
... imports omitted

@Entity
public class Address {

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private long id;

	private String street;
	private int number;

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public String getStreet() {
		return street;
	}

	public void setStreet(String street) {
		this.street = street;
	}

	public int getNumber() {
		return number;
	}

	public void setNumber(int number) {
		this.number = number;
	}

}

----

Example code

[source, java]
----
@Entity
public class Employee {

  @Id
  private long id;


  // fails with the exception that JPA does not know what type of column to create for Address? Clear??
  private Address address;
}
----

Fix the problem above with the *@OneToOne* annotation so JPA knows that it has to make a mapping to another table called a *relationship* / *foreign key*

[source, java]
----
@Entity
public class Employee {

  @Id
  private long id;


  @OneToOne
  private Address address;
}
----

Using the least work principe that is all we have to do to create the relationship

.Under the hood JPA does the following work for us
* it creates the table *Address*
* it creates an *address_id* column in the table Person

Now we have create a so called *unidirectional relationship* which means we can only traverse from the Person to the Address

*The address table / entity does not have any clue to which person it belongs!!!*

=== Bidirectional
Suppose we want to tell JPA also to wire the direction from Address to Person
Than we have to add this to the JPA Address entity

[source, java]
----
  // fetch = do we get all addressen when fetching a Person or do we fetch them when we "dive" into them ...
  /// mappedBy = the other / owning side his property (in this case address since that is the owning side of Person)
 @OneToOne(fetch=FetchType.LAZY, mappedBy="address")
  private Person person;

  // add getters and setters
----

Question: what happens to the tables in the people app?




Answer ... after a minute of discussing? 
Nothing ... why ? :-)

Since if jpa has an adress entity he can found the person by finding a person with an adress_id which is the samen as the id of this address instance.


== @OneToMany

=== Unidirectional

Suppose a person has many phones AND a phone belongs to one person

image::ObjectRelational-ManyToOne.jpg[]


We than use the *@OneToMany* annotation

[source, java]
----
@OneToMany
private Set<Phone> phones = new HashSet<>();
----

JPA then creates a person_phones table? Why ?

Since the entity Phone does not know that he is even linked to a Person hence JPA creates a so called *link table*
(Dutch: koppel tabel)

=== Bidirectional
Suppose we want to be able to get the person which own the phone

Add the mappedBy property to the @OneToMany annotation on the owning side

The mappedBy is ALWAYS the type of the Set we are dealing with. Hence in this case it is the Phone class - which has the @ManyToOne - annotation.
Just pick the name of the variable and you are done ... for now :-)

[source, java]
----
@OneToMany(mappedBy="person") // person is the private Person instance var in the phone class
private Set<Phone> phones;
----

.Add the @ManyToOne annotation to the belonging side
[source, java]
----
@ManyToOne
private Person person;
----

== @ManyToMany

=== Introducing jointable

In a ManyToMany relationship we have a so-called many-to-many relationship between two classes.

e.g. A Person can have many hobbies and a hobby can have many Person(s).

JPA will create a so called join-table / link-table (Dutch: koppeltabel) to link the relationship between the two

=== Introducing Cascading

During this ManyToMany relationship part we also are talking about Cascading.
In this case, cascading means ... what should we do when we delete a Person? Should we also delete his phones in the relationship?

What you should know is that the @ManyToMany annotation has a 'cascade' attribute which you can set.

.That cascade attribute should contain an 'CascadeType' enum value which are ...
* ALL
* PERSIST
* MERGE
* REMOVE
* REFRESH
* DETACH

You are telling with this annotation what JPA should do on the action.
So if we say ... cascade=CascadeType.REMOVE on the Person class on the Hobbies set than removing a Person will also remove the links from the linktable after deletion

.More explaination regarding Cascading
* https://stackoverflow.com/questions/4935095/jpa-hibernate-many-to-many-cascading

=== Unidirectional

Suppose a person has many hobbies and a hobby can belong to multiple persons

.class diagram
image::GraphExplainingPersonHobbyMappingProgramItYed.jpg[]

.Add this to the person class
[source, java]
----
@ManyToMany(cascade=CascadeType.ALL)
private Set<Hobby> hobbies = new HashSet<>();
----

The machine creates a join table (in this case *hobbies_people*)

=== Bidirectional

Suppose want to see al people who like *running*

.Add the following to the Person class (mappedBy)
[source, java]
----
@ManyToMany(mappedBy="people", cascade=CascadeType.ALL)
private Set<Hobby> hobbies = new HashSet<>();
----

.Add the following to the Hobby class
[source, java]
----
@ManyToMany(cascade=CascadeType.ALL)
private Set<Person> people = new HashSet<>();
----

TIP: Never use a mappedBy on both sides of the relationship. Simply only on the *owning* side

TIP: Be aware for the following. Using a getter to get the Set of Hobbies out of person and than adding an item to the Set will eventually fail.
You have to add a hobby through the owning class (in this case through Person)

.Solution: create a getter and create an addHobby to the Person class
[source, java]
----
 public void addHobby(Hobby h) {
        this.hobbies.add(h);
		h.getPeople().add(this);
}
----



== What is that Cascade thing?

* When a person is deleted what happens to the hobby?
** The Cascading defines what should happen to the underlying properties of an entity
** In fact we have to tell something about assocations and specially regarding aggregations and compositions
* I think it is for later for now :-)


== DIY
.Do it yourself

* Implement the above changes to your people project
** Add Address-entity and add the @OneToOne relationship
** Add Phone-entity and add the @OneToMany relationship
** Add Hobby-entity and add the @ManyToMany relationship
* Watch what happens during the starting of the application with your database-structure


== More Resources
* https://www.thoughts-on-java.org/association-mappings-bag-list-set/
* https://stackoverflow.com/questions/4935095/jpa-hibernate-many-to-many-cascading
